2017/12/06
◆27.3. pdb — Python デバッガ — Python 3.6.3 ドキュメント
https://docs.python.jp/3/library/pdb.html
実行するプログラムをデバッガで分析する典型的な使い方
import pdb; pdb.set_trace()
s(tep)
	現在の行を実行し、最初に実行可能なものがあらわれたときに (呼び出された関数の中か、現在の関数の次の行で) 停止します。
n(ext)
	現在の関数の次の行に達するか、あるいは関数が返るまで実行を継続します。 
	(step が呼び出された関数の内部で停止するのに対し、 next は呼び出された関数を全速力で実行し、現在の関数内の次の行で停止するだけです。)
c(ont(inue))
	ブレークポイントに出会うまで、実行を継続します。
l(ist) [first[, last]]
	現在のファイルのソースコードを表示します。
a(rgs)
	現在の関数の引数リストをプリントします。
p expression
	現在のコンテキストにおいて expression を評価し、その値をプリントします。
pp expression
	p コマンドに似ていますが、式の値以外は pprint モジュールを使用して "pretty-print" されます。

◆Python Web フレームワーク: 第 1 回 Django と Python を使って Web 開発
https://www.ibm.com/developerworks/jp/linux/library/l-django/index.html
filterメソッドとexcludeメソッドはQuerySetオブジェクトを返します。
QuerySetオブジェクトは、つなげてチェーンにすることができ、さらにはジョインを実行することもできます。
	from jobs.models import Job
	from datetime import datetime
	q3 = Job.objects.filter(pub_date__gte=datetime(2006, 1, 1))
	q4 = q3.filter(location__city__exact="Cleveland", location__state__exact="Ohio")
QuerySetは評価されるまでデータベースに対して実行しない
Pythonの『スライス（slice）』機能と組み合わせると、実際のSQLクエリーで大幅にパフォーマンスを向上させています。
	from jobs.models import Job
	for job in Job.objects.all()[5:15]
		print job
QuerySetの中のレコード数を数えるには、countメソッドを使います。
	from jobs.models import Job
	print "Count = ", Job.objects.count()       # GOOD!
	print "Count = ", len(Job.objects.all())    # BAD!

◆Anaconda/python仮想環境ファイルの置き場所、ソースコード
C:\Users\ryu\AppData\Local\conda\conda\envs\djangorest
C:\Users\ryu\AppData\Local\conda\conda\envs\djangorest\Lib\site-packages


◆モデルフィールドリファレンス — Django 1.4 documentation
http://docs.djangoproject.jp/en/latest/ref/models/fields.html
全てのフィールド型で、以下の引数を指定できます。これらの引数はすべてオプショ ンです。
null
Trueにすると、Djangoは空の値をNULLとしてデータベースに入れます。デフォルト値はFalseです。
空の文字列値はNULLではなく空文字列として保存されることに注意して下さい。
null=Trueが使えるのは、文字列ではないフィールド型の場合だけです。
nullはデータベースでの記録操作にのみかかわるパラメタなので、
フォーム上で空の値を入力できるようにしたければblank=Trueも指定する必要があるでしょう。
blank
Trueにすると、フィールドの値を空白(blank)にできます。デフォルト値はFalseです。
nullとは違うことに注意してください。
nullが純粋にデータベース上の表現に関わる概念であるのに対し、blankとは値の検証(validation)に関わる概念です。
あるフィールドにblank=Trueを指定すると、Djangoのadminサイト上で、空の値のエントリを作成できます。
blank=Falseにすると、そのフィールドには必ず値を入れねばなりません。


◆anacondaではない公式python
仮想環境の有効化
>C:\Users\s920342\Documents\python\django\Scripts\activate
サーバ起動
>py manage.py runserver 0.0.0.0:8000

◆データベース構築
mysite/settings.py
INSTALLED_APPS = [
    ...
    'meas',
]
>python manage.py makemigrations
>python manage.py migrate

データベース削除
$ python manage.py flush --database=default



2017/09/08

>conda create -n djangorest django
>activate djangorest
>conda install -c conda-forge djangorestframework
>conda install -c conda-forge django-filter

>conda list

>cd project_folder
>django-admin startproject mysite .
>python manage.py startapp meas

モデルの定義 meas/models.py
from django.db import models
# Create your models here.
import uuid
class Entry(models.Model):
    description = models.CharField(max_length=256)
    condition = models.CharField(max_length=256)
    created_at = models.DateTimeField(auto_now_add=True)
    uuid = models.UUIDField(default=uuid.uuid4)
    item = models.CharField(max_length=64)
    value = models.FloatField()
    unit = models.CharField(max_length=16, blank=True)




管理者画面にデータベースエントリ追加 meas/admin.py
from django.contrib import admin
from .models import Entry
@admin.register(Entry)
class Entry(admin.ModelAdmin):
    pass

動作確認
>python manage.py createsuperuser
>python manage.py runserver
http://localhost:8000/admin

REST Frameworkの追加 mysite/settings.py
INSTALLED_APPS = (
    ...
    'meas',
    'rest_framework',
)

Serializerの定義 meas/serializer.py
from rest_framework import serializers
from .models import Entry

class EntrySerializer(serializers.ModelSerializer):
    class Meta:
        model = Entry
        fields = ('description', 'condition', 'created_at', 'uuid', 'item', 'value', 'unit')

ViewSetの定義 meas/views.py
import django_filters
from rest_framework import viewsets, filters

from .models import Entry
from .serializer import EntrySerializer

class EntryViewSet(viewsets.ModelViewSet):
    queryset = Entry.objects.all()
    serializer_class = EntrySerializer

URL pattern定義 mysite/urls.py
from django.conf.urls import url, include
from django.contrib import admin
from meas.urls import router
urlpatterns = [
    url(r'^admin/', admin.site.urls),
    url(r'^api/', include(router.urls)),
]

URL pattern定義 meas/urls.py
from rest_framework import routers
from .views import EntryViewSet
router = routers.DefaultRouter()
router.register(r'entries', EntryViewSet)

動作確認
>python manage.py runserver
http://localhost:8000/api/
http://localhost:8000/api/entries/

外部からアクセス
>python manage.py runserver 0.0.0.0:8000
mysite/settings.py
ALLOWED_HOSTS = [‘*’]

JSON登録例
{
    "description": "B301_test L0 Nothing",
    "condition": "L0",
    "created_at": "2017-09-08T06:02:21.221695Z",
    "uuid": "1990e31b-928c-4619-9c64-acd882a416d9",
    "item": "SNR",
    "value": 6.94,
    "unit": "dB"
}

ページネイション
ペジネーションを使う場合は、DjangoREST用に設定が必要
mysite/settings.py
REST_FRAMEWORK = {
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.LimitOffsetPagination',
    'PAGE_SIZE': 20,
}


admin画面のEntry一覧表示に、追加情報を加える、サイドにフィルタを加える
meas/admin.py
class Entry(admin.ModelAdmin):
    list_display =('description', 'created_at', 'condition')
    list_filter = ['created_at']


admin画面で表示されるEntryの複数形を、EntrysからEntriesに変更する
meas/model.py
class Entry(models.Model):
    ...
    class Meta:
        verbose_name_plural = "entries"

モデル変更を検討、ConditionとEntryを分けてリレーションモデルにする

class Condition(models.Model):
    description = models.CharField(max_length=256)
    condition = models.CharField(max_length=256)
    created_at = models.DateTimeField(auto_now_add=True)
    lane = models.IntegerField(blank=True)
    uuid = models.UUIDField(default=uuid.uuid4, unique=True)

class Entry(models.Model):
    uuid = models.ForeignKey('Condition', to_field='uuid')
    item = models.CharField(max_length=64)
    value = models.FloatField()
    unit = models.CharField(max_length=16, blank=True)
    class Meta:
        verbose_name_plural = "entries"

1つの項目を抽出するときは、get()
複数の項目を抽出するときは、filter()

views.pyに記載されているclassはview
urls.pyのurl()の第2引数に入れるのはviewsetが必要
view classのas_view()メソッドを使うと、viewsetになる


viewには、関数ベースのビューとクラスベースのビューがある
どちらを使うべきかという問題があるが、トレードオフがある
関数ベースview：defで定義する、関数の中でGET,POSTなどのHTTPメソッドを分離する
クラスベースview：classで定義する、classの中に、HTTPメソッドに対応するメソッドを作成する
http://sandmark.hateblo.jp/entry/2017/10/02/164636
http://sandmark.hateblo.jp/entry/2017/10/01/125909


http://docs.djangoproject.jp/en/latest/topics/class-based-views.html
Django 1.3 の前は、汎用ビューは関数として実装されていました。
ここで述べる クラスベース汎用ビューが採用されたので、関数ベース汎用ビューは廃止されま した。


https://developer.mozilla.org/en-US/docs/Learn/Server-side/Django/Generic_views
url(r'^serials/(?P<pk>[-\w]+)$', views.SerialDetailView, name='serial_detail'),
正規表現
^ 文頭
$ 文末
\d 数値（0-9）
\w 文字列（英小文字、英大文字、数値、アンダースコア）
(?P<name>...) マッチしたパターンをname変数に格納してviewに渡す


エラー対策

TypeError at /meas/series/20171107173949
__init__() takes 1 positional argument but 2 were given
	urls.pyのurl()のviewにas_view()が付いていない

NameError at /meas/series/20171107173949
name 'pk' is not defined


AttributeError at /meas/series/20171107162431
Generic detail view SeriesDetailView must be called with either an object pk or a slug.
